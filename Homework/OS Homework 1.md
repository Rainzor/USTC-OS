# OS Homework1

##### 		PB20020480 王润泽

操作系统就是管理和控制硬件软件，合理调度和分配系统资源，为用户和应用提供接口与环境的程序集合。

1. #### 请分别从系统和用户的角度，阐述操作系统的功能。

操作系统需要做的事情是：

- 管理硬件，与硬件进行交互，提供底层的一些元素
- 给应用提供运行的环境

系统角度：操作系统是与硬件紧密联系相连的程序，所以操作系统可以看作资源分配器，管理类似于：CPU时间，内存空间，文件存储，I/O设备。合理为各个程序和用户分配资源。同时OS也可以看作控制程序，管理用户程序的执行。

用户角度：对单个用户，OS是优化用户进行的工作，使用户使用方便。对多用户来说，用户间要共享资源交换信息，所以OS需要优化资源利用利率。对于别复杂的情况，操作系统要同时兼顾使用方便和资源利用率。

2. #### 概述 multi-programming 和 multi-tasking 的概念及其设计目的。

multi-programming：即多道程序设计，指通过安排作业（job）使得CPU总有一个执行作业，不会因为等待某个作业的完成而空闲，提高CPU利用率。

multi-tasking：即分时系统或多任务系统，虽然是multi-programming的延伸，CPU通过切换作业来执行多个作业，但由于切换频率很高，远超过用户的反应（I/O）速度，用户可以在程序运行时与操作系统交互，发送指令。同时multi-tasking能够允许多用户同时共享一台计算机。

3. #### 概述存储的层次以及缓存的思想。

存储的层次：主要分为三级：CPU中的寄存器，内存，硬盘。

缓存：因为硬件的访问速度随着硬件容量的增大而减小，平时将信息保存在大容量的存储系统中，当使用时，则被临时复制更快的存储层次（缓存）中，由于数据读写的空间时间局部性，当再次要读写数据时，首先去缓存中查找，如果缓存了数据，则读写速度大大加快，提高速率。

4. #### 解释什么是系统调用，详细阐述系统调用与 API 的逻辑关系。

**系统调用：**

system call 是提供操作系统服务的接口，是进程与操作系统内核的程序接口，为用户的程序提供一些方式去命令系统完成相应的任务。如get_pid (),fork() , brk()

系统调用就是一种特殊的接口。通过这个接口，用户可以访问内核空间。系统调用规定了用户进程进入内核的具体位置。

​    系统调用是用户进程进入内核的接口层，它本身并非内核函数，但它是由内核函数实现，进入内核后，不同的系统调用会找到各自对应的内核函数，这些内核函数被称为系统调用的“服务例程”。比如系统调用getpid实际调用了服务例程为sys_getpid(),或者说系统调用getpid是服务例程sys_getpid()的“封装例程”。![API和系统调用的区别](http://hiphotos.baidu.com/as132699/pic/item/82189e7ead4e374229388a1f.jpg)

​    具体步骤：用户进程-->系统调用-->内核-->返回用户空间。

系统调用就是为了解决上述问题而引入的，是提供给用户的“特殊接口”。

  系统调用规定用户进程进入内核空间的具体位置。

  1.程序运行空间从用户空间进入内核空间。

  2.处理完后再返回用户空间

**API（Application Programming Interface）：**

即应用程序接口，为方便应用程序员规定了一组函数，包括函数的输入参数与返回值。

是程序员在用户空间下可以直接使用的函数接口。是一些预定义的函数，如read()、malloc()、free()、abs()函数

对于操作系统，用户可以通过操作系统的函数库来调用相应的API,从而间接为用户调用实际的系统调用（system call)。API能将系统调用的大多细节隐藏起来，只为用户提供相应的接口，系统能调用接口，截取API函数，以此调用操作系统所需要的系统调用。这样可以提高程序的可移植性。

**关系：**

有时候，某些API所提供的功能会涉及到与内核空间进行交互。那么，这类API内部会封装系统调用。而不涉及与内核进行交互的API则不会封装系统调用。也就是说，API和系统调用并没有严格的一一对应关系，一个API可能恰好只对应一个系统调用，比如read()系统调用和read()；一个API也可能由多个系统调用实现；有时候，一个API的功能可能并不需要内核提供的服务，那么此时这个API也就不需要任何的系统调用，比如abs()。另外，一个系统调用可能还被多个API内部调用。

Application Programmer Interface（API）与 system call 相比较而言，前者是获取相关服务的一种函数定义，而后者是通过软件中断向内核发起的请求。unix 系统包含了一些库，其中 libc 标准C库对 system call 进行了封装，然后以 API 的形式提供给用户。每一个系统调用都对应着一个这样的封装的 API，而反过来就不是了。因为 libc 中很多的 API 并不需要进行系统调用，而有的 API 是将多个系统调用进行组合使用，还有的 API 使用的是同样的系统调用，比如 malloc、calloc、free 都是用的 brk 系统调用。

用户调用API，API调用 System call来完成系统操作

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220615204811469.png" alt="image-20220615204811469" style="zoom:67%;" />

5. #### 阐述 Dual Mode 的工作机制，以及采用 Dual Mode 的原因。

Dual Mode：即双重模式，为了保证OS正常运行以保护OS，防止操作系统和用户程序受到错误的用户程序影响，必须区分操作系统代码和用户代码的执行，因而分成了用户模式（user mode）和内核模式（kernel mode）。

其工作机制是：计算机硬件可以通过一个模式位来表示当前模式：kernel mode（0），user mode（1）。当计算机系统执行用户应用时，系统处于user mode。当用户应用通过系统调用，请求OS服务时，系统从user mode 切到 kernel mode，以满足请求。当调用完或者遇到中断时，又会回到user mode。



6. #### 概述操作系统需要提供哪些服务。

程序执行 program execute、I/O操作、文件系统操作 File systems、通信 communication、资源分配 allocation、记账 accounting 、错误检测 error detection、保护与安全 protection ＆security

另外OS还要提供用户界面。





7. #### 分别阐述 Monolithic 单片结构，层次化结构，模块化结构和微内核结构的特点和优劣。

**Monolithic单片结构**：特点：由内核与系统程序独立组成。	优点：系统调用接口与内核的通信的开销很小，性能很好	缺点：难以维护和实现

**层次化结构**：特点：将操作系统分成若干层级，操作系统层采用抽象对象，用来包含数据和对数据的操作。所选的层次要求每层只能调用更低层的功能和服务。	优点：简化了构建和debug，每层为更高层隐藏了数据结构、操作和硬件。	缺点：难以定义每一层结构；层与层之间数据的通信拷贝降低了系统效率。

**微内核结构**：特点：内核只保留最核心的功能，把剩下的部件当作系统级和用户级程序来实现。	优点：便于拓展操作系统，可移植性，更加稳定可靠。	缺点：增加了内存的开销，微内核性能会受损

微内核（Microkernel kernel）――在微内核中，大部分内核都作为单独的进程在特权状态下运行，他们通过消息传递进行通讯。在典型情况下，每个概念模块都有一个进程。因此，假如在设计中有一个系统调用模块，那么就必然有一个相应的进程来接收系统调用，并和能够执行系统调用的其他进程（或模块）通讯以完成所需任务。

**模块化结构**：特点：采用可加载的内核模块，内核只提供核心服务，其他的服务可在内核运行时动态实现。	优点：更加的灵活，模块之间通信也更加高效

#### 8.举例说明什么是机制与策略分离的设计原则，并说明该设计的好处。

比如要实现CPU保护这一目标

机制是：采用时间定时器机制；策略是：对于具体的程序，应当设置不同的时间来区别实现。

好处：策略可随时间地点而改变，而机制具有稳定不变性，使系统更加灵活



#### 9.内核

Linux 内核是 Linux 操作系统（OS）的主要组件，也是计算机硬件与其进程之间的核心接口。它负责两者之间的通信，还要尽可能高效地管理资源。

之所以称为内核，是因为它在操作系统中就像果实硬壳中的种子一样，并且控制着硬件（无论是电话、笔记本电脑、服务器，还是任何其他类型的计算机）的所有主要功能。

内核有 4 项工作：

1. **内存管理：**追踪记录有多少内存存储了什么以及存储在哪里
2. **进程管理：**确定哪些进程可以使用中央处理器（CPU）、何时使用以及持续多长时间
3. **设备驱动程序：**充当硬件与进程之间的调解程序/解释程序
4. **系统调用和安全防护：**从流程接受服务请求

在正确实施的情况下，内核对于用户是不可见的，它在自己的小世界（称为内核空间）中工作，并从中分配内存和跟踪所有内容的存储位置。用户所看到的内容（例如 Web 浏览器和文件）则被称为用户空间。这些应用通过系统调用接口（SCI）与内核进行交互。

举例来说，内核就像是一个为高管（硬件）服务的忙碌的个人助理。助理的工作就是将员工和公众（用户）的消息和请求（进程）转交给高管，记住存放的内容和位置（内存），并确定在任何特定的时间谁可以拜访高管、会面时间有多长。

为了更具象地理解内核，不妨将 Linux 计算机想象成有三层结构：

1. **硬件**：物理机（这是系统的底层结构或基础）是由内存（RAM）、处理器（或 CPU）以及输入/输出（I/O）设备（例如存储、网络和图形）组成的。其中，CPU 负责执行计算和内存的读写操作。
2. **Linux 内核**：处于操作系统的核心位置。驻留在内存中的软件，用于告诉 CPU 要执行哪些操作。
3. **用户进程**：这些是内核所管理的运行程序。用户进程共同构成了用户空间。用户进程有时也简称为进程。内核还允许这些进程和服务器彼此进行通信（称为进程间通信或 IPC）。

系统执行的代码通过以下两种模式之一在 CPU 上运行：内核模式或用户模式。在内核模式下运行的代码可以不受限制地访问硬件，而用户模式则会限制 SCI 对 CPU 和内存的访问。内存也存在类似的分隔情况（内核空间和用户空间）。这两个小细节构成了一些复杂操作的基础，例如安全防护、构建容器和虚拟机的权限分隔。

这也意味着：如果进程在用户模式下失败，则损失有限，无伤大雅，可以由内核进行修复。另一方面，由于内核进程要访问内存和处理器，因此内核进程的崩溃可能会引起整个系统的崩溃。由于用户进程之间会有适当的保护措施和权限要求，因此一个进程的崩溃通常不会引起太多问题。

***

